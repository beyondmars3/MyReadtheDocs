# java

## JVM 内存布局
- 参考: https://www.cnblogs.com/scofield-1987/p/7502969.html

1. heap堆    
- new 出来的对象
- 新生代/老年代/永久代
- 新生代中又分成了两部分Eden区和Survivor区
-  -Xms = 1024M -Xmx = 2048M; 表示JVM Heap的初始大小为1GB，最大可自动伸缩到2GB；

2. 方法区     class类信息,常量(常量池),静态变量,即时编译器编译后的代码
- 在Hotspot JVM中，设计者使用“永久代”来实现方法区
- XX:MAXPermSize来设定永久代的内存上限。

3.  JVM栈（Java虚拟机栈）
- JVM栈是伴随着线程的产生而产生的，属于线程私有区域，生命周期和线程保持一致，所以，JVM的内存管理器对这部分内存无需管理；
- 栈中有包含了多个栈帧. 主要保存方法的局部变量、操作数栈、动态链接、方法出口（reternAddress或者抛Exception）。

## 对象的布局和内存组成

1. 对象头(header),对象实例数据（Instance Data）和对齐填充（Padding)
2. 对象头又包含两部分内容：Markword和reference（类类型指针）
- Markword 存储的有 哈希码、GC分代年龄、偏向锁标记、线程持有的锁、偏向线程ID、偏向时间戳等。
3. reference 用于指向对象的类的元数据的指针。 通过这个指针，JVM可以知道，这个对象是属于哪个类的实例对象。

## 垃圾回收

1. 引用计数
- 对象头中分配一个空间来保存该对象被引用的次数（Reference Count). 为0时,会被回收.
- 不属于严格意义上的"Stop-The-World"
- 没法解决循环依赖

2. 可达性分析算法
- 引用链(GC Roots)作为根节点,往下搜索路径。 当一个对象到GC Roots没有路径时,是不可达的
- 成功解决,循环依赖
 
3. GC Roots 的对象
- 虚拟机栈(栈帧中得局部变量表)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区的常量引用对象

## 标记清除算法

## 分代收集算法
1. 新生代 
- 尽可能快的回收掉那些短期的对象
- 按照8:1:1  eden区和survivor0和survivor1 区

2. 老年代
- 存放都是生命周期长的对象
- 满时会触发Full gc
- 内存大小是新生代的2倍

3. 永久代
- 用来存放静态文件

4. gc 
- 对新生代的回收，不影响老年代。 因为回收频繁，所以要求速度快

5. full gc
- 对整个堆回收，速度慢







